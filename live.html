<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>TrustCheck Live STT</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 16px; max-width: 980px; margin: 0 auto; }
    button { margin-right: 8px; padding: 10px 14px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .card { background: #f4f4f4; padding: 12px; border-radius: 10px; }
    pre { background: #f4f4f4; padding: 12px; white-space: pre-wrap; border-radius: 8px; }
    #partial { opacity: 0.7; }
    .badge { padding: 6px 10px; border-radius: 999px; font-weight: 700; display: inline-block; }
    .low { background: #d7f7d7; }
    .medium { background: #fff1c2; }
    .high { background: #ffd1d1; }
    .muted { opacity: 0.7; }
  </style>
</head>
<body>
  <h2>TrustCheck: Live Speech-to-Text + Live Risk</h2>

  <div class="row card">
    <div id="status">status: idle</div>
    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="analyzeBtn" disabled>Analyze transcript</button>
    <span class="muted">Auto-analyze: every 5s (final transcript)</span>
  </div>

  <div class="row card">
    <div>Risk:</div>
    <div id="riskBadge" class="badge medium">MEDIUM</div>
    <div id="riskScore" class="muted">score: -</div>
  </div>

  <div class="card">
    <div class="muted">Summary</div>
    <div id="summary">—</div>
  </div>

  <div class="card">
    <div class="muted">Red flags</div>
    <ul id="flags"></ul>
  </div>

  <h3>Final transcript</h3>
  <pre id="final"></pre>

  <h3>Partial</h3>
  <pre id="partial"></pre>

  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <script>
    // Connect to same origin (Render) and force WebSocket transport (better for Telegram WebView)
    const socket = io(window.location.origin, { transports: ["websocket"] });

    const statusEl = document.getElementById("status");
    const finalEl = document.getElementById("final");
    const partialEl = document.getElementById("partial");
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const analyzeBtn = document.getElementById("analyzeBtn");

    const riskBadge = document.getElementById("riskBadge");
    const riskScoreEl = document.getElementById("riskScore");
    const summaryEl = document.getElementById("summary");
    const flagsEl = document.getElementById("flags");

    let audioContext, processor, source, stream;
    let isRunning = false;
    let finalText = "";
    let lastAnalyzedText = "";
    let analyzeInFlight = false;
    let lastPartialTs = 0;

    function setStatus(s) { statusEl.textContent = "status: " + s; }

    function setRisk(level, score) {
      const lvl = (level || "medium").toLowerCase();
      riskBadge.className = "badge " + (lvl === "low" ? "low" : lvl === "high" ? "high" : "medium");
      riskBadge.textContent = (lvl || "medium").toUpperCase();
      riskScoreEl.textContent = "score: " + (score ?? "-");
    }

    function setSummary(t) { summaryEl.textContent = t || "—"; }

    function setFlags(flags) {
      flagsEl.innerHTML = "";
      if (!Array.isArray(flags) || flags.length === 0) return;
      for (const f of flags) {
        const li = document.createElement("li");
        const t = f.type || "flag";
        const sev = f.severity || "";
        const ev = f.evidence || "";
        li.textContent = `${t} (${sev}): ${ev}`;
        flagsEl.appendChild(li);
      }
    }

    function downsampleBuffer(buffer, sampleRate, outRate) {
      if (outRate === sampleRate) return buffer;
      const ratio = sampleRate / outRate;
      const newLen = Math.round(buffer.length / ratio);
      const result = new Float32Array(newLen);
      let offsetResult = 0;
      let offsetBuffer = 0;
      while (offsetResult < result.length) {
        const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
        let accum = 0, count = 0;
        for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
          accum += buffer[i];
          count++;
        }
        result[offsetResult] = accum / count;
        offsetResult++;
        offsetBuffer = nextOffsetBuffer;
      }
      return result;
    }

    function floatTo16BitPCM(float32Array) {
      const len = float32Array.length;
      const buf = new ArrayBuffer(len * 2);
      const view = new DataView(buf);
      for (let i = 0; i < len; i++) {
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7fff, true);
      }
      return new Uint8Array(buf);
    }

    async function analyzeText(text) {
      if (!text || text.length < 30) return;
      if (analyzeInFlight) return;
      analyzeInFlight = true;
      try {
        const r = await fetch("/analyze-text", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ text })
        });
        const data = await r.json().catch(() => ({}));
        setRisk(data.risk_level, data.risk_score);
        setSummary(data.summary);
        setFlags(data.red_flags);
      } catch (e) {
        setSummary("Risk analyze failed (temporary).");
      } finally {
        analyzeInFlight = false;
      }
    }

    // Auto-analyze every 5 seconds if final text changed
    setInterval(() => {
      if (!isRunning) return;
      if (finalText && finalText !== lastAnalyzedText && finalText.length >= 30) {
        lastAnalyzedText = finalText;
        analyzeText(finalText);
      }
    }, 5000);

    socket.on("status", (m) => {
      setStatus(m.state);
      if (m.state === "streaming") analyzeBtn.disabled = false;
    });

    socket.on("error", (m) => setStatus("error: " + m.message));

    socket.on("transcript", (m) => {
      if (m.isPartial) {
        const now = Date.now();
        if (now - lastPartialTs < 200) return;
        lastPartialTs = now;
        partialEl.textContent = m.text;
      } else {
        partialEl.textContent = "";
        finalText += (finalText ? " " : "") + m.text;
        finalEl.textContent = finalText;
      }
    });

    async function start() {
      if (isRunning) return;
      isRunning = true;
      finalText = "";
      lastAnalyzedText = "";
      finalEl.textContent = "";
      partialEl.textContent = "";
      setStatus("requesting mic...");

      stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      source = audioContext.createMediaStreamSource(stream);

      processor = audioContext.createScriptProcessor(2048, 1, 1); // lower latency

      processor.onaudioprocess = (e) => {
        if (!isRunning) return;
        const input = e.inputBuffer.getChannelData(0);
        const down = downsampleBuffer(input, audioContext.sampleRate, 16000);
        const pcm16 = floatTo16BitPCM(down);
        // Send binary to server (faster than base64)
        socket.emit("audio", pcm16.buffer);
      };

      source.connect(processor);
      processor.connect(audioContext.destination);

      socket.emit("start", { languageCode: "en-US", sampleRateHertz: 16000 });

      startBtn.disabled = true;
      stopBtn.disabled = false;
      analyzeBtn.disabled = false;
    }

    async function stop() {
      if (!isRunning) return;
      isRunning = false;
      socket.emit("stop");

      stopBtn.disabled = true;
      startBtn.disabled = false;

      if (processor) processor.disconnect();
      if (source) source.disconnect();
      if (audioContext) await audioContext.close();
      if (stream) stream.getTracks().forEach(t => t.stop());

      setStatus("idle");
    }

    startBtn.onclick = start;
    stopBtn.onclick = stop;

    analyzeBtn.onclick = () => analyzeText(finalText);
  </script>
</body>
</html>
